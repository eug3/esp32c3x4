#!/usr/bin/env python3
"""
生成内置中文字体 C 文件
使用 lv_font_conv 工具从 TTF 字体生成 LVGL 可用的字体
"""

import os
import sys
import subprocess
import struct

# 配置
FONT_NAME = "GenJyuuGothic"
TTF_FILE = "GenJyuuGothic-Monospace-Light-2.ttf"
CHARS_FILE = "common_chinese_chars.txt"
OUTPUT_C_FILE = "builtin_chinese_font.c"
OUTPUT_HEADER_FILE = "builtin_chinese_font.h"

# 字体参数
FONT_SIZE = 16  # 字体大小
BPP = 4        # 每像素位数 (4 = 16 级灰度)

def read_chinese_chars(filepath):
    """读取常用汉字列表"""
    with open(filepath, 'r', encoding='utf-8') as f:
        content = f.read()
        # 去除空白字符，只保留汉字
        chars = ''.join(content.split())
        # 去重并排序
        unique_chars = sorted(set(chars))
        return unique_chars

def generate_font_with_lv_font_conv(ttf_path, chars, size, bpp, output_bin):
    """使用 lv_font_conv 生成字体"""

    # 构建 symbols 参数
    # 将字符转换为 Unicode 码点范围
    char_codes = [hex(ord(c)) for c in chars]
    symbols_str = ','.join(char_codes)

    cmd = [
        'lv_font_conv',
        '--size', str(size),
        '--bpp', str(bpp),
        '--font', ttf_path,
        '--symbols', symbols_str,
        '--format', 'bin',
        '-o', output_bin,
        '--force-fast-kern-format',
        '--no-compress'
    ]

    print(f"Running command: {' '.join(cmd)}")

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(result.stdout)
        if result.stderr:
            print("STDERR:", result.stderr)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error running lv_font_conv: {e}")
        print(f"stdout: {e.stdout}")
        print(f"stderr: {e.stderr}")
        return False
    except FileNotFoundError:
        print("Error: lv_font_conv not found. Please install it first:")
        print("  pip install lv_font_conv")
        return False

def bin_to_c_array(bin_file, c_file, font_name):
    """将二进制字体文件转换为 C 数组"""

    with open(bin_file, 'rb') as f:
        data = f.read()

    # 生成 C 文件内容
    c_content = f"""/**
 * @file {os.path.basename(c_file)}
 * @brief Auto-generated built-in Chinese font for LVGL
 *
 * Font: {font_name}
 * Size: {FONT_SIZE}px
 * BPP: {BPP}
 * Characters: {len(chars)} common Chinese characters
 *
 * Generated by generate_builtin_font.py
 */

#include "lvgl/lvgl.h"
#include <stdint.h>

#ifndef LV_FONT_BUILTIN_CHINESE
#define LV_FONT_BUILTIN_CHINESE 1
"""

    # 添加数据数组
    array_name = f"builtin_chinese_font_data"
    c_content += f"\n// Font data ({len(data)} bytes)\n"
    c_content += f"const uint8_t {array_name}[] = {{\n"

    # 每行 16 字节
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_str = ', '.join(f'0x{b:02x}' for b in chunk)
        c_content += f"    {hex_str},\n"

    c_content += "};\n\n"

    # 添加字体描述符结构
    # 这需要根据 lv_font_conv 的输出格式来构建
    # 由于 bin 格式包含完整的 lv_font_fmt_txt_dsc_t，我们需要正确解析

    c_content += f"""
// Built-in Chinese font
// Note: This is a placeholder. The actual font structure needs to be
// constructed based on the lv_font_conv binary format.
extern const uint8_t {array_name}[];

"""

    # 写入文件
    with open(c_file, 'w', encoding='utf-8') as f:
        f.write(c_content)

    print(f"Generated C file: {c_file}")
    print(f"  Data size: {len(data)} bytes ({len(data)/1024:.1f} KB)")

    return len(data)

def generate_header_file(header_file, font_name):
    """生成头文件"""

    h_content = f"""/**
 * @file {os.path.basename(header_file)}
 * @brief Built-in Chinese font declaration
 */

#ifndef BUILTIN_CHINESE_FONT_H
#define BUILTIN_CHINESE_FONT_H

#include "lvgl.h"

#ifdef __cplusplus
extern "C" {{
#endif

/**
 * @brief Get the built-in Chinese font
 * @return Pointer to the built-in LVGL font
 */
const lv_font_t* get_builtin_chinese_font(void);

/**
 * @brief Check if a character is available in the built-in font
 * @param unicode_char Unicode character code point
 * @return true if available, false otherwise
 */
bool builtin_font_has_char(uint32_t unicode_char);

#ifdef __cplusplus
}}
#endif

#endif // BUILTIN_CHINESE_FONT_H
"""

    with open(header_file, 'w', encoding='utf-8') as f:
        f.write(h_content)

    print(f"Generated header file: {header_file}")

def main():
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)

    print("=" * 60)
    print("Built-in Chinese Font Generator")
    print("=" * 60)

    # 检查文件是否存在
    if not os.path.exists(TTF_FILE):
        print(f"Error: TTF file not found: {TTF_FILE}")
        print(f"Please place {TTF_FILE} in the same directory as this script.")
        return 1

    if not os.path.exists(CHARS_FILE):
        print(f"Error: Characters file not found: {CHARS_FILE}")
        return 1

    # 读取字符集
    print(f"\n1. Reading Chinese characters from {CHARS_FILE}...")
    chars = read_chinese_chars(CHARS_FILE)
    print(f"   Found {len(chars)} unique characters")

    # 生成临时 bin 文件
    temp_bin = f"temp_{FONT_NAME}_{FONT_SIZE}px.bin"
    print(f"\n2. Generating font binary with lv_font_conv...")
    print(f"   Font: {TTF_FILE}")
    print(f"   Size: {FONT_SIZE}px")
    print(f"   BPP: {BPP}")

    if not generate_font_with_lv_font_conv(TTF_FILE, chars, FONT_SIZE, BPP, temp_bin):
        print("\nError: Failed to generate font binary")
        print("\nAlternative: Use lvgl's built-in font converter")
        print("You can also manually create the font using:")
        print(f"  lv_font_conv --size {FONT_SIZE} --bpp {BPP} --font {TTF_FILE} --symbols <your_symbols> --format bin -o {OUTPUT_C_FILE.replace('.c', '.bin')}")
        return 1

    # 转换为 C 文件
    print(f"\n3. Converting to C array...")
    data_size = bin_to_c_array(temp_bin, OUTPUT_C_FILE, FONT_NAME)

    # 生成头文件
    print(f"\n4. Generating header file...")
    generate_header_file(OUTPUT_HEADER_FILE, FONT_NAME)

    # 清理临时文件
    if os.path.exists(temp_bin):
        os.remove(temp_bin)
        print(f"\n5. Cleaned up temporary file: {temp_bin}")

    print("\n" + "=" * 60)
    print("Generation complete!")
    print("=" * 60)
    print(f"\nGenerated files:")
    print(f"  - {OUTPUT_C_FILE} ({data_size} bytes)")
    print(f"  - {OUTPUT_HEADER_FILE}")
    print(f"\nNext steps:")
    print(f"  1. Add these files to your project")
    print(f"  2. Update CMakeLists.txt to include them")
    print(f"  3. Rebuild and flash your project")
    print("=" * 60)

    return 0

if __name__ == "__main__":
    sys.exit(main())
