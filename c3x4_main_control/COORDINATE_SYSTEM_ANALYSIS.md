# EPD 坐标系统完整分析

## 1. 物理屏幕坐标系

**EPD硬件物理尺寸**: 800像素(宽) × 480像素(高)

```
物理屏幕 (0,0) 在左上角
     0 ────────────────────> 799 (X轴，宽)
   0 ┌─────────────────────┐
   │ │                     │
   │ │                     │
   │ │    800 × 480       │
   │ │                     │
   │ │                     │
 479 └─────────────────────┘
   ↓
  (Y轴，高)
```

**Framebuffer物理布局**:
- 尺寸: 48000字节 (800 × 480 / 8)
- Stride: 100字节/行 (800 / 8)
- 格式: 1bpp, MSB first
- 字节索引: `byte_idx = phys_y * 100 + phys_x / 8`
- 位索引: `bit = 7 - (phys_x % 8)`

## 2. 逻辑屏幕坐标系 (ROTATE_270)

**应用逻辑尺寸**: 480像素(宽) × 800像素(高) - 竖屏显示

```
逻辑屏幕 (0,0) 在左上角（旋转后）
     0 ──────────────> 479 (X轴，宽)
   0 ┌──────────────┐
   │ │              │
   │ │              │
   │ │              │
   │ │  480 × 800  │
   │ │              │
   │ │              │
   │ │              │
 799 └──────────────┘
   ↓
  (Y轴，高)
```

## 3. ROTATE_270 坐标变换

**变换规则**（来自GUI_Paint.c第209-211行）:
```c
case 270:
    X = Ypoint;                    // 物理X = 逻辑Y
    Y = Paint.HeightMemory - Xpoint - 1;  // 物理Y = 479 - 逻辑X
```

**对于单点**:
- 逻辑点(lx, ly) → 物理点(ly, 479 - lx)

**对于区域**（display_engine.c的convert_logical_to_physical_region）:
```c
逻辑区域: (lx, ly, lw, lh) 在480×800坐标系
物理区域: (px, py, pw, ph) 在800×480坐标系

// 左上角转换
px1 = ly
py1 = 479 - lx

// 右下角转换
px2 = ly + lh - 1
py2 = 479 - (lx + lw - 1) = 479 - lx - lw + 1

// 因为Y轴反转，需要交换py1和py2
// 最终物理区域起点
px = ly
py = 479 - lx - lw + 1
pw = lh
ph = lw
```

## 4. 测试案例分析

### 案例1: 左上角矩形
**逻辑坐标**: (10, 10, 50, 50)
- 预期位置: 距离左边10px，距离上边10px

**物理变换**:
- px = ly = 10
- py = 479 - lx - lw + 1 = 479 - 10 - 50 + 1 = 420
- pw = lh = 50
- ph = lw = 50

**物理区域**: (10, 420, 50, 50)
- 实际位置: x∈[10,59], y∈[420,469]

**验证**: 
- 从物理屏幕左边算: x=10 ✓
- 从物理屏幕上边算: y=420
- 但是！物理屏幕是横屏800×480，用户看到的是竖屏

**用户视角**（旋转270度后）:
- 物理(10, 420)在逻辑坐标应该在...

等等，我需要重新理解用户的观察视角！

## 5. 用户观察视角 vs 代码坐标

**关键理解**:
- 用户拿着设备，看到的是**竖屏** (480宽×800高)
- 代码/EPD驱动操作的是**物理横屏** (800宽×480高)
- ROTATE_270 = 物理屏幕逆时针旋转270度 = 顺时针旋转90度

**用户视角的"左上角"**（逻辑屏幕）:
- 逻辑坐标 (0, 0)
- 对应物理坐标 (0, 479) - 物理屏幕的左下角

**用户视角的"右下角"**（逻辑屏幕）:
- 逻辑坐标 (479, 799)
- 对应物理坐标 (799, 0) - 物理屏幕的右上角

## 6. 重新分析测试结果

### 右下角矩形: (420, 740, 50, 50)
**预期**:
- 逻辑坐标: 距离右边10px (480-420-50=10)，距离下边10px (800-740-50=10)

**物理变换**（使用当前代码公式）:
- 对于矩形内每个点(temp_x, temp_y)，逻辑点为(420+temp_x, 740+temp_y)
- 物理点 = (740+temp_y, 479-(420+temp_x))
- phys_x ∈ [740, 789]
- phys_y ∈ [479-469, 479-420] = [10, 59]

**物理framebuffer**: x∈[740,789], y∈[10,59]

**EPD_4in26_Display_Part_Stream的Y反转**:
```c
UWORD y_reversed = 480 - y - h = 480 - 10 - 50 = 420
```
所以实际读取的是 y∈[420, 469]

**等等！这里有问题！**

让我重新看EPD驱动的代码...

## 7. 问题定位

用户报告：
- 右下角出现了
- 距离右边60px，距离下边20px

预期：
- 距离右边10px，距离下边10px

偏差：
- 右边多了50px (60-10)
- 下边多了10px (20-10)

**hypothesis**: 
1. 宽度计算错误？50px矩形变成了60px？
2. 高度计算错误？50px矩形变成了20px？
3. 还是位置就不对？

需要用户更详细的反馈来定位问题。
