#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Generate a firmware-embedded codepoint table for font cache.

This script reads a UTF-8 text file that contains characters to cache (e.g.
《通用规范汉字表》一级字表的 3500 个汉字), plus it can optionally add common
punctuation.

It outputs a C header that defines:
  - FONT_CACHE_LEVEL1_TABLE_COUNT
  - g_font_cache_level1_table[] (sorted ascending, uint16_t)

Usage:
  python3 tools/generate_level1_table.py tools/level1_3500_chars.txt \
      --out main/ui/font_cache_level1_table.h

Input format:
  - Any UTF-8 text is accepted.
  - Whitespace/newlines are ignored.
  - Duplicate characters are de-duplicated.

Notes:
  - Only BMP codepoints (<= 0xFFFF) are emitted (uint16_t).
  - The repository does NOT ship the 3500 chars to avoid licensing ambiguity.
"""

from __future__ import annotations

import argparse
from pathlib import Path


COMMON_PUNCT = [
    "，", "。", "、", "；", "：", "？", "！",
    "“", "”", "‘", "’",
    "（", "）", "【", "】", "《", "》",
    "—", "…", "·",
    "-", "_", "/", "\\",
    ".", ",", ":", ";", "?", "!",
    "(", ")", "[", "]", "{", "}",
    "\"", "'",
    "%", "#", "@", "&", "*", "+", "=",
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
]


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("input", type=Path, help="UTF-8 text file containing characters")
    ap.add_argument("--out", type=Path, required=True, help="Output header path")
    ap.add_argument("--no-punct", action="store_true", help="Do not auto-add punctuation")
    args = ap.parse_args()

    text = args.input.read_text(encoding="utf-8")

    cps: set[int] = set()
    for ch in text:
        if ch.isspace():
            continue
        cp = ord(ch)
        if cp <= 0xFFFF:
            cps.add(cp)

    if not args.no_punct:
        for ch in COMMON_PUNCT:
            cp = ord(ch)
            if cp <= 0xFFFF:
                cps.add(cp)

    cps_sorted = sorted(cps)

    out = args.out
    out.parent.mkdir(parents=True, exist_ok=True)

    lines: list[str] = []
    lines.append("// Auto-generated by tools/generate_level1_table.py")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <stdint.h>")
    lines.append("")
    lines.append(f"#define FONT_CACHE_LEVEL1_TABLE_COUNT {len(cps_sorted)}u")
    lines.append("")

    if len(cps_sorted) == 0:
        # Keep a dummy array to satisfy C compilation.
        lines.append("static const uint16_t g_font_cache_level1_table[1] = { 0x0000u };")
    else:
        lines.append(f"static const uint16_t g_font_cache_level1_table[{len(cps_sorted)}] = {{")
        # format 12 per line
        chunk: list[str] = []
        for i, cp in enumerate(cps_sorted, 1):
            chunk.append(f"0x{cp:04X}u")
            if len(chunk) == 12:
                lines.append("    " + ", ".join(chunk) + ",")
                chunk = []
        if chunk:
            lines.append("    " + ", ".join(chunk) + ",")
        lines.append("};")

    out.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Wrote {out} with {len(cps_sorted)} codepoints")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
