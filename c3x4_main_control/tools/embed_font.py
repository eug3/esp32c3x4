#!/usr/bin/env python3
"""
Convert binary font files to embedded C code.

Creates a minimal embedded font containing only essential characters for menu display.

Usage:
    python embed_font.py <input.bin> <output_dir> [--chars-only <count>] [--char-list <file>]

This script reads a XTEinkFontBinary file and generates C code that embeds
only the most common characters, allowing menus to use the embedded font
without SD card access.
"""

import sys
import os
import struct
import argparse

def read_font_header(data):
    """Parse XTEinkFontBinary header"""
    if len(data) < 36:
        raise ValueError("Font file too small for header")
    
    header = struct.unpack('<IBBBBI4I8B', data[:36])
    magic, version, width, height, bpp, _, char_count, first_char, last_char, glyph_size, file_size = header[:11]
    
    return {
        'magic': magic,
        'version': version,
        'width': width,
        'height': height,
        'bpp': bpp,
        'char_count': char_count,
        'first_char': first_char,
        'last_char': last_char,
        'glyph_size': glyph_size,
        'file_size': file_size,
    }

def get_glyph_data(data, char_index, glyph_size, header_size=36):
    """Extract glyph data for a specific character index"""
    start = header_size + char_index * glyph_size
    end = start + glyph_size
    if end > len(data):
        return None
    return data[start:end]

def load_common_chars(filename):
    """Load common character list from file"""
    chars = []
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                # Each line should contain a character
                if len(line) > 0:
                    chars.append(ord(line[0]))
    except Exception as e:
        print(f"Warning: Could not load char list: {e}")
    return chars

def generate_minimal_font(data, header_info, char_indices):
    """Generate minimal font with only selected characters"""
    glyph_size = header_info['glyph_size']
    header_size = 36
    first_char = header_info['first_char']
    
    # Build character map: unicode -> glyph_data
    char_map = {}
    for char_code in char_indices:
        # Calculate index in original font
        idx = char_code - first_char
        if idx < 0 or idx >= header_info['char_count']:
            continue
        
        glyph = get_glyph_data(data, idx, glyph_size, header_size)
        if glyph:
            char_map[char_code] = glyph
    
    return char_map

def generate_c_header(font_name, header_info, char_count, essential_chars):
    """Generate C header file"""
    guard = f"__EMBEDDED_{font_name.upper()}_H__"
    
    code = f"""/**
 * @file embedded_{font_name}.h
 * @brief Embedded {font_name} font - minimal version for menu
 * 
 * Auto-generated by embed_font.py
 * Original font: {header_info['width']}x{header_info['height']} pixels
 * Embedded characters: {char_count} (essential menu chars + {len(essential_chars)} CJK chars)
 */

#ifndef {guard}
#define {guard}

#include <stdint.h>

// Font header information
#define EMBEDDED_FONT_WIDTH {header_info['width']}
#define EMBEDDED_FONT_HEIGHT {header_info['height']}
#define EMBEDDED_FONT_GLYPH_SIZE {header_info['glyph_size']}
#define EMBEDDED_FONT_CHAR_COUNT {char_count}

// Font character data (organized by Unicode codepoint)
extern const uint8_t g_{font_name}_data[];
extern const uint32_t g_{font_name}_data_size;

// Character index map for quick lookup
// Maps Unicode -> offset in data array
extern const uint16_t g_{font_name}_index[];
extern const uint16_t g_{font_name}_index_count;

#endif // {guard}
"""
    return code

def generate_c_source(font_name, char_map, header_info):
    """Generate C source file with embedded data"""
    glyph_size = header_info['glyph_size']
    
    # Sort by unicode for consistent ordering
    sorted_chars = sorted(char_map.keys())
    
    code = f"""/**
 * @file embedded_{font_name}.c
 * @brief Embedded {font_name} font data
 * 
 * Auto-generated by embed_font.py
 * Font size: {header_info['width']}x{header_info['height']} pixels
 * Glyph size: {glyph_size} bytes
 * Total characters: {len(sorted_chars)}
 */

#include "embedded_{font_name}.h"

// Embedded font glyph data
// Each character is stored as {glyph_size}-byte bitmap
const uint8_t g_{font_name}_data[] = {{
"""
    
    # Write glyph data
    data_offset = 0
    index_entries = []
    
    for char_code in sorted_chars:
        glyph = char_map[char_code]
        
        # Record index entry (unicode -> offset)
        index_entries.append((char_code, data_offset))
        
        # Write glyph bytes
        code += f"    // U+{char_code:04X} ({chr(char_code) if 32 <= char_code < 127 else '?'})\n"
        for i in range(0, len(glyph), 16):
            chunk = glyph[i:i+16]
            hex_str = ', '.join(f'0x{{:02x}}'.format(b) for b in chunk)
            code += f"    {hex_str},\n"
        
        data_offset += len(glyph)
    
    code += f"""
}};

const uint32_t g_{font_name}_data_size = sizeof(g_{font_name}_data);

// Character index (Unicode codepoint -> offset in data)
// Format: [codepoint_low, codepoint_high, offset_low, offset_high]
const uint16_t g_{font_name}_index[] = {{
"""
    
    for char_code, offset in index_entries:
        code += f"    0x{char_code:04x}, 0x{offset:04x},  // U+{char_code:04X} @ offset {offset}\n"
    
    code += f"""
}};

const uint16_t g_{font_name}_index_count = {len(index_entries)};
"""
    
    return code

def main():
    parser = argparse.ArgumentParser(description='Embed font data for menu system')
    parser.add_argument('input', help='Input font file (XTEinkFontBinary format)')
    parser.add_argument('output_dir', help='Output directory for C files')
    parser.add_argument('--chars-only', type=int, default=3500,
                       help='Include first N characters only (default: 3500)')
    parser.add_argument('--char-list', help='File with list of characters to include')
    parser.add_argument('--name', default='menu_default_font',
                       help='C identifier prefix (default: menu_default_font)')
    
    args = parser.parse_args()
    
    # Read font file
    with open(args.input, 'rb') as f:
        data = f.read()
    
    print(f"Reading font from: {args.input}")
    print(f"Font size: {len(data) / 1024 / 1024:.2f} MB")
    
    # Parse header
    try:
        header_info = read_font_header(data)
        print(f"Font info:")
        print(f"  Dimensions: {header_info['width']}x{header_info['height']} pixels")
        print(f"  Total characters: {header_info['char_count']}")
        print(f"  Char range: U+{header_info['first_char']:04X} - U+{header_info['last_char']:04X}")
        print(f"  Glyph size: {header_info['glyph_size']} bytes")
    except Exception as e:
        print(f"Error parsing font header: {e}")
        sys.exit(1)
    
    # Determine which characters to include
    char_indices = []
    essential_chars = set()
    
    # Always include ASCII characters (menu labels, etc.)
    for code in range(32, 127):
        essential_chars.add(code)
    
    # Add from character list if provided
    if args.char_list and os.path.exists(args.char_list):
        print(f"Loading common characters from: {args.char_list}")
        listed_chars = load_common_chars(args.char_list)
        essential_chars.update(listed_chars)
        print(f"Loaded {len(listed_chars)} characters from list")
    else:
        # Include first N characters from font
        for i in range(min(args.chars_only, header_info['char_count'])):
            char_code = header_info['first_char'] + i
            essential_chars.add(char_code)
    
    char_indices = list(essential_chars)
    
    print(f"Total characters to embed: {len(char_indices)}")
    
    # Generate minimal font
    char_map = generate_minimal_font(data, header_info, char_indices)
    print(f"Successfully extracted {len(char_map)} glyphs")
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Generate files
    c_source = generate_c_source(args.name, char_map, header_info)
    c_header = generate_c_header(args.name, header_info, len(char_map), essential_chars)
    
    # Write header
    header_file = os.path.join(args.output_dir, f"embedded_{args.name}.h")
    with open(header_file, 'w', encoding='utf-8') as f:
        f.write(c_header)
    print(f"✓ Generated: {header_file}")
    
    # Write source
    source_file = os.path.join(args.output_dir, f"embedded_{args.name}.c")
    with open(source_file, 'w', encoding='utf-8') as f:
        f.write(c_source)
    print(f"✓ Generated: {source_file}")
    
    # Estimate size
    source_size = len(c_source) / 1024
    print(f"\nEmbedded font size: ~{source_size:.1f} KB (C source)")
    print(f"This includes {len(char_map)} glyphs × {header_info['glyph_size']} bytes each")

if __name__ == '__main__':
    main()

