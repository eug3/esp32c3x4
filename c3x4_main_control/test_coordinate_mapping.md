# 坐标映射测试

## 目的
验证 LVGL 逻辑坐标到 EPD 物理坐标的映射是否正确

## 测试案例

### 案例 1: welcome_menu_btnm 区域

**LVGL 逻辑坐标**:
- x=[20, 459]（左偏移 20，宽度 440）
- y=[200, 399]（上偏移 200，高度 200）

**映射到 EPD 物理坐标** (ROTATE_270):
- memX = y = [200, 399]
- memY = 479 - x = [20, 459]

**预期结果**: EPD 应该在 x=[200, 399], y=[20, 459] 的位置显示菜单

---

### 案例 2: 单个像素

**LVGL 逻辑坐标 (20, 272)**:
- x=20, y=272

**映射到 EPD 物理坐标**:
- memX = 272
- memY = 479 - 20 = 459

**framebuffer 位置**:
- byte_index = 459 * 100 + 272/8 = 45900 + 34 = 45934

**验证刷新任务读取**:

如果 LVGL flush 区域是 x=[20, 279], y=[272, 295]:
- 映射到 EPD: memX=[272, 295], memY=[200, 459]
- 读取起始位置: y=200, x=272
- byte_index = 200 * 100 + 272/8 = 20000 + 34 = 20034

**问题**: 写入到 byte_index=45934，但从 byte_index=20034 读取！

---

## 问题分析

写入位置 (LVGL x=20, y=272):
- memY = 479 - 20 = 459
- byte_index = 459 * 100 + 34 = 45934

读取位置 (刷新从 memY=200 开始):
- byte_index = 200 * 100 + 34 = 20034

**结论**: 写入和读取位置不匹配！

## 原因

LVGL flush 区域 x=[20, 279] 包含多个不同的 x 值，每个 x 值映射到不同的 memY：
- x=20 → memY=459
- x=279 → memY=200

刷新任务使用的是 **映射后的边界** (memY=[200, 459])，但是数据被写入到这个范围内的多个不同位置。

由于 ROTATE_270 映射，LVGL 的一个矩形区域会映射到 EPD 的另一个矩形区域，但是 **这个映射是正确的**。

真正的问题可能是：**framebuffer 的读取方式**。

## 验证方法

查看日志输出：
1. `[PIXEL]` 日志显示写入的 byte_index
2. `[FLUSH] Mapped to EPD` 日志显示刷新区域
3. `Read starts at` 日志显示读取的起始位置

如果写入的 byte_index 和读取的 byte_index 范围不重叠，就证明存在读取位置错误。
